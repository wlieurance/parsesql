% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/classes.R
\name{sql_parser}
\alias{sql_parser}
\title{Parse, separate and format multi-statement SQL strings}
\description{
An R6 Class with variables and methods to store,
manipulate and print Structured Query Language (SQL) with multiple
statements in string format. The class parses each statement and assigns
a 'state' to each character, identifying that character as having no
specific state, as being part of a comment, or as being quoted. The class
also parses out key words from the statement for use in display or
printing.
}
\examples{

## ------------------------------------------------
## Method `sql_parser$new`
## ------------------------------------------------

sql_parser$new(text = "SELECT cal1 FROM tbl1; SELECT col2 FROM tbl2;")
sql_parser$new(text = "SELECT {cols} FROM tbl1",
               params = list(cols = "col1, col2"))
sql_parser$new(file = "/path/to/file.sql",
               standard = "PostgreSQL")
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{text}}{A character string containing one or more SQL statements
separated by a semicolon.}

\item{\code{file}}{A character string. A path to a file containing SQL to parse.}

\item{\code{standard}}{A character string. An SQL standard from which to
identify Reserved Words from. One of:
\code{c('SQL-92', 'SQL:2011', 'SQL:2016', 'PostgreSQL')}}

\item{\code{params}}{A named list of character strings. Contains parameters to
replace in the SQL code. Parameters need to be identically named and
contained by brackets \{\} in the SQL file.}

\item{\code{reserved}}{A character string vector which is populated from the
global \code{standards} variable and filtered during class initialization by
choice of the \code{standard} field.}

\item{\code{param_text}}{A character string. A string sourced from \code{text} or
\code{file} where parameters which have been enclosed in brackets in the
string have been replaced by their values in \code{params}.}

\item{\code{char_states}}{A list of tibbles, one tibble for each statement.
Each tibble contains two columns, 'char' and 'state', a single
character field and a list encapsulated named logical vector
containing that character's state respectively.}

\item{\code{stripped_states}}{A list of tibbles. A stripped version of
\code{char_states} where white space characters have been removed from the
beginning and end of statement tibbles.}

\item{\code{string_states}}{A list of tibbles, one tibble for each statement.
Each tibble contains three columns, 'state', 'state_no' and 'string'.
'state' is a list encapsulated named logical vector containing
a string's state. 'state_no' is the order in the statement in which the
string/state occurs. 'string' is the concatenation of individual
characters from \code{stripped_states} 'char' field which share the same
state before a new state is detected.}

\item{\code{sql}}{A list of character strings, one string for each statement.}

\item{\code{formatted}}{A list of character strings, on string for each
statement where strings have been color and style formatted by state via
the \code{crayon} package.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{sql_parser$new()}}
\item \href{#method-read_fp}{\code{sql_parser$read_fp()}}
\item \href{#method-get_state}{\code{sql_parser$get_state()}}
\item \href{#method-strip_single}{\code{sql_parser$strip_single()}}
\item \href{#method-strip_ws}{\code{sql_parser$strip_ws()}}
\item \href{#method-string_group}{\code{sql_parser$string_group()}}
\item \href{#method-combine_states}{\code{sql_parser$combine_states()}}
\item \href{#method-format_char}{\code{sql_parser$format_char()}}
\item \href{#method-group_df}{\code{sql_parser$group_df()}}
\item \href{#method-combine_stmts}{\code{sql_parser$combine_stmts()}}
\item \href{#method-print}{\code{sql_parser$print()}}
\item \href{#method-clone}{\code{sql_parser$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new SqlParser object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$new(text = NA, file_path = NA, standard = "SQL:2016", params = NA)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{text}}{A character string containing one or more SQL statements
separated by a semicolon (mutually exclusive with \code{file_path}).}

\item{\code{file_path}}{A character string. A path to an existing file
containing one or more SQL statements separated by a semicolon
(mutaually exclusive with \code{text}).}

\item{\code{standard}}{A character string. An SQL standard from which to
identify Reserved Words from. One of:
\code{c('SQL-92', 'SQL:2011', 'SQL:2016', 'PostgreSQL')}}

\item{\code{params}}{A named list of character strings. Contains parameters to
replace in the SQL code. Parameters need to be identically named and
contained by brackets \{\} in the SQL file.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{SqlParser} object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{sql_parser$new(text = "SELECT cal1 FROM tbl1; SELECT col2 FROM tbl2;")
sql_parser$new(text = "SELECT {cols} FROM tbl1",
               params = list(cols = "col1, col2"))
sql_parser$new(file = "/path/to/file.sql",
               standard = "PostgreSQL")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-read_fp"></a>}}
\if{latex}{\out{\hypertarget{method-read_fp}{}}}
\subsection{Method \code{read_fp()}}{
Reads in file text and stores within the class if there is
no text argument given.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$read_fp(f)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{A character string which is a file path to an existing file
containing one or more SQL statements separated by a semicolon.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_state"></a>}}
\if{latex}{\out{\hypertarget{method-get_state}{}}}
\subsection{Method \code{get_state()}}{
Parses character string multi-statement SQL one character
at a time and assigns a state to that character pertaining to whether it
is single-quoted, dollar quoted, a quoted identifier, or a comment.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$get_state()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-strip_single"></a>}}
\if{latex}{\out{\hypertarget{method-strip_single}{}}}
\subsection{Method \code{strip_single()}}{
Finds white space characters at the beginning and end of a
tibble produced by the \code{get_state} method and removes them.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$strip_single(stmt)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{stmt}}{A tibble with two columns, 'char' and 'state', a single
character field and a list encapsulated named logical vector
containing that character's state respectively.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A tibble in the form of \code{stmt} with beginning and end rows of a
statement removed if they contain white space characters.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-strip_ws"></a>}}
\if{latex}{\out{\hypertarget{method-strip_ws}{}}}
\subsection{Method \code{strip_ws()}}{
Applies the \code{strip_single} method over a list of tibbles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$strip_ws()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-string_group"></a>}}
\if{latex}{\out{\hypertarget{method-string_group}{}}}
\subsection{Method \code{string_group()}}{
Combines characters that have the same state into strings
and stores them along with state and order in a tibble.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$string_group(stripped)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{stripped}}{A tibble with two columns, 'char' and 'state', a single
character field and a list encapsulated named logical vector
containing that character's state respectively. Produced from the
\code{strip_single} method.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A tibble containing three columns, 'state', 'state_no' and
'string'. 'state' is a list encapsulated named logical vector
containing a string's state. 'state_no' is the order in the statement
in which the string/state occurs. 'string' is the concatenation of
individual characters from \code{stripped_states} 'char' field which share
the same state before a new state is detected.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-combine_states"></a>}}
\if{latex}{\out{\hypertarget{method-combine_states}{}}}
\subsection{Method \code{combine_states()}}{
Applies the \code{string_group} method over a list of tibbles.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$combine_states()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-format_char"></a>}}
\if{latex}{\out{\hypertarget{method-format_char}{}}}
\subsection{Method \code{format_char()}}{
Takes a character string  and a state and assigns a color
and style to the string using the crayon package.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$format_char(my_chars, my_state, reserved)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{my_chars}}{A character string containing the text to format.}

\item{\code{my_state}}{A named logical vector containing state information for
\code{my_chars}.}

\item{\code{reserved}}{A character vector of key words to color and
\strong{bold}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A color/style formatted version of \code{my_chars}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-group_df"></a>}}
\if{latex}{\out{\hypertarget{method-group_df}{}}}
\subsection{Method \code{group_df()}}{
Combines SQL with different states into a single statements,
both unformatted for execution and formatted for printing/display.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$group_df(df, reserved)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{A tibble produced from the \code{string_group} method.}

\item{\code{reserved}}{A character vector of key words to color and
\strong{bold}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named list containing the SQL statement (sql) and a formatted
version for printing (formatted).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-combine_stmts"></a>}}
\if{latex}{\out{\hypertarget{method-combine_stmts}{}}}
\subsection{Method \code{combine_stmts()}}{
Applies the \code{group_df} method over a list of tibbles and
separates the output into two separate class variables, \code{sql} and
\code{formatted}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$combine_stmts()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Prints the formatted SQL statements separated by a dashed
line
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{additional arguments to print}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{sql_parser$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
